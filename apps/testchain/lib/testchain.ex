defmodule Staxx.Testchain do
  @moduledoc """
  Default module for controlling different EVM's
  """

  require Logger

  alias Staxx.Testchain.EVMRegistry
  alias Staxx.Storage

  @data_file_name "evm_data.bin"

  @typedoc """
  Chain EVM type.

  Available types are:
   - `:ganache` -  Ganache blockchain
   - `:geth` - Geth evm
   - `:geth_vdb` - Special geth evm version from https://github.com/vulcanize/go-ethereum
   - `:parity` - Parity evm
  """
  @type evm_type :: :ganache | :geth | :geth_vdb | :parity

  @typedoc """
  Big random number generated by `unique_id/0` that identifiers new chain id
  """
  @type evm_id :: binary()

  @doc """
  Generate uniq ID

  It also checks if such ID exist in runing processes list
  and checks if chain db exist for this `id`
  """
  @spec unique_id() :: evm_id()
  def unique_id() do
    <<new_unique_id::big-integer-size(8)-unit(8)>> = :crypto.strong_rand_bytes(8)
    new_unique_id = to_string(new_unique_id)

    with nil <- get_pid(new_unique_id),
         nil <- Storage.get(new_unique_id),
         false <- File.exists?(evm_db_path(new_unique_id)) do
      new_unique_id
    else
      _ ->
        unique_id()
    end
  end

  @doc """
  Write any additional information to `evm_data.json` file into chain DB path.
  Thi sfile will be used any any other processes for storage info in there.
  """
  @spec write_external_data(evm_id(), term) :: :ok | {:error, term}
  def write_external_data(_id, nil), do: :ok

  def write_external_data(id, data) do
    path = evm_db_path(id)

    with true <- File.exists?(path),
         encoded <- :erlang.term_to_binary(data, compressed: 1),
         file_path <- Path.join(path, @data_file_name),
         :ok <- File.write(file_path, encoded) do
      :ok
    else
      false ->
        {:error, "No chain path exists"}

      {:error, err} ->
        {:error, err}

      err ->
        err
    end
  end

  @doc """
  Read all additional information that is stored with chain
  """
  @spec read_external_data(evm_id()) :: {:ok, nil | map} | {:error, term}
  def read_external_data(id) do
    path =
      id
      |> evm_db_path()
      |> Path.join(@data_file_name)

    with true <- File.exists?(path),
         {:ok, content} <- File.read(path),
         data <- :erlang.binary_to_term(content, [:safe]) do
      {:ok, data}
    else
      false ->
        {:ok, nil}

      {:error, err} ->
        {:error, err}
    end
  end

  @doc """
  Load list of evms version used in app
  """
  @spec version() :: binary
  def version() do
    {:ok, v} = :application.get_key(:testchain, :vsn)
    "Application version: #{to_string(v)}"
  end

  @doc """
  Generate EVM DB path for chain
  """
  @spec evm_db_path(evm_id()) :: binary
  def evm_db_path(id) do
    Application.get_env(:testchain, :base_path, "/tmp")
    |> Path.expand()
    |> Path.join(id)
  end

  # Try lo load pid by given id
  defp get_pid(id) do
    case Registry.lookup(EVMRegistry, id) do
      [{pid, _}] ->
        pid

      _ ->
        nil
    end
  end
end
